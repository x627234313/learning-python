#### 原生协程语法
```python
async def read_data(db):
    pass
```
定义一个原生协程函数，async def 函数中可以没有await语句。

#### await
```python
async def read_data(db):
    data = await db.fetch('select * from table')
```
await用于接收可被异步等待的awaitable对象的返回值，awaitable对象有以下几种：
- 调用原生协程函数返回的原生协程
- 被`@asyncio.coroutine`装饰的生成器函数调用后返回的生成器协程
- 实现了`__await__`魔术方法的对象；
    - `__await__`方法必须返回迭代器，否则会报TypeError。实现了`__await__`方法的对象也被称为**类似未来对象(Future-like)**

await后面只能跟着awaitable对象，否则会报TypeError。而且await必须在async def的函数中使用。

#### 协程调用
###### 事件循环策略
asyncio中引入了事件循环策略的概念。事件循环策略是全局对象，每个进程一个。
```python
asyncio.get_event_loop_policy()  # 获取当前的事件循环策略
asyncio.set_enent_loop_policy(policy)  # 设置当前的事件循环策略
```
uvloop是一个很高效的第三方事件循环策略框架，利用上面两个接口可以让uvloop代替内置的事件循环策略
```python
policy = uvloop.EventLoopPolicy()
asyncio.set_event_loop_policy(policy)
```
事件循环策略中引入了事件循环上下文的概念。一个事件循环的上下文，就是指一个线程。即每个线程可以设置不同的事件循环。？？？没理解
###### 事件循环
asyncio提供了三个接口来获取或设置事件循环：
```python
default_loop = asyncio.get_event_loop()  # 获取当前线程的事件循环
default_loop = asyncio.get_event_loop_policy().get_event_loop()

asyncio.set_event_loop(loop)  # 为当前线程设置事件循环
asyncio.get_event_loop_policy().set_event_loop(loop)

new_loop = asyncio.new_event_loop()  # 根据当前事件循环策略生成一个新的事件循环
new_loop = asyncio.get_event_loop_policy().new_event_loop()
```
经验1：同一个Python进程中，最好只使用一种事件循环策略，且在多线程情况下只使用该策略生成的事件循环对象。

经验2:：子线程中有异步时，需在子线程内先设置事件循环，或将主线程中获取到的循环对象传递给子线程。

经验3：一个Python进程最好只有一种事件循环策略，只使用一个事件循环对象。

