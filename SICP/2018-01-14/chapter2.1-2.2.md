# 2 用对象构建抽象
面向对象编程背后的核心思想是：以数据作为抽象(规则、指导方法)

## 2.1 介绍
在第1章我们集中在计算过程和函数在程序设计中的作用。 我们看到了如何使用原始数据（数字）和原始操作（算术运算），如何通过组合和控制形成复合函数，以及如何通过给过程命名来创建功能抽象。 我们还看到，高阶函数通过授权我们通过一般的计算方法来操纵和推理，从而增强了我们语言的能力。 这是编程的本质。
  
本章重点介绍数据。 数据使我们能够使用迄今为止获得的计算工具来表示和操纵有关世界的信息。 没有数据结构的程序可能足以探索数学属性。 但是，真实世界的现象，如文件，关系，城市和天气模式，都具有复杂的结构，最好用*复合数据类型*表示。 通过结构化的数据，程序可以模拟和推理人类知识和经验的任何领域。 由于互联网的爆炸式增长，大量关于世界的结构化信息在网上免费提供给我们。

### 2.1.1 对象隐喻
在本课程开始时，我们区分了函数和数据：函数是进行操作的，数据是被操作的。 当我们把函数作为值放到数据中去时，我们承认数据也可以有行为。 函数可以像数据一样被操作，但是也可以被调用来执行计算。
  
*对象*表现信息，但也表现行为像它们所代表的抽象概念。对象如何与其他对象交互的逻辑与编码在对象里的值的信息绑定在一起。 对象既是信息又是过程，捆绑在一起表示复杂事物的属性，交互和行为。
  
  日期是一种简单的对象。
  ```
  >>> from datetime import date
  ```
名称`date`绑定到一个*类*。一个类代表一种对象。单独的日期被称为该类的*实例*，并且可以通过将该类作为表征该实例的参数的函数来构造它们。

> 类 对象 实例：楼房图纸代表一个类，根据该图纸建造的楼房都叫做该类的对象，单独的一栋楼房叫做该类的实例。

> 一个类的对象；一个类代表一种对象

> 一个民族的人；一个民族代表一类人

对象具有*属性*，这些属性是被命名的值，作为对象的一部分。在Python中，我们使用点号来访问对象的属性。
```
<expression>.<name>
```

> 对表达式求值，得到的是它背后所代表的对象。所谓的“看山不是山”

对象也具有*方法*，这些方法属性的值是函数。比喻的说，对象“知道”如何执行这些方法。方法从它们的参数和它们的对象计算它们的结果。

尽管我们还没有精确地描述对象是如何工作的，现在是时候开始将数据视为对象，因为在Python中，每个值都是一个对象。

### 2.1.2 原生数据类型
Python中每个对象都有*类型*。`type`函数让我们可以检查每个对象的类型。
```python
>>> type(today)
<class 'datetime.date'>
```
到目前为止，我们学习的对象类型有数字、函数、布尔和现在的日期。我们也简要的学习了集合和字符串，但是我们需要更深入的学习它们。还有很多其他类型的对象---声音、图象、位置、数据、关系等等。---其中大部分可以被定义，通过组合和我们本章中开发的抽象手段。Python只有少量的原始或原生的数据类型内置在语言中。

原生数据类型具有以下的属性：
1. 有一些原始的表达式可以对这些类型的对象求值，叫做*标量*。
2. 有一些内置的函数、运算符和方法来操作这些对象。

事实上，Python包含三种原始数值类型：整数(`int`)、实数(`float`)、复数(`complex`)。

## 2.2 数据抽象
当我们考虑在程序中表示世界的大量东西时，我们发现大多数是复合结构。日期有年，月，日; 地理位置有纬度和经度。为了表示位置，我们希望我们的编程语言有能力将经纬度“粘合在一起”，形成一对---一个复合数据值---我们的程序以一种与事实一致的方式操纵它，我们把一个位置看作一个单独的概念单位，由两部分组成。

使用复合数据也增加了我们程序的模块化。如果我们可以把地理位置直接作为自己的对象来操作，那么我们就可以将我们程序中处理值的部分从这些值如何表示的细节中分离出来。 **将处理数据如何表示部分与处理数据如何操作部分隔离的一般性技术是一种强大的设计方法论，被称为*数据抽象*。数据抽象使程序更容易设计，维护和修改。**

数据抽象在性质上与函数抽象类似。当我们创建一个函数抽象时，函数的实现细节可以被抑制，特定的函数本身可以被任何其他具有相同整体行为的函数所替代。换句话说，我们可以构造一个抽象，将函数的使用方式与函数的实现细节分开。 类似地，**数据抽象是一种方法论，它使我们能够从如何构建它的细节中分离出如何使用复合数据对象。**

**数据抽象的基本思想是构造程序，以便对抽象数据进行操作。也就是说，我们的程序应该以尽可能少和数据假设方式使用数据。同时，定义一个具体的数据表示，独立与使用数据的程序。我们系统的这两部分之间的接口是一组函数，称为选择器和构造器，用具体的表示来实现抽象数据**。为了说明这个技巧，我们将考虑如何设计一组操作有理数的函数。

**计算机科学不仅仅是学习使用编程语言，还要学习如何工作。**

### 2.2.1 示例：有理数的算术
回想一下，有理数是整数的一个比例，有理数是实数的一个重要子类。 像1/3或17/29这样的有理数通常被写成：
```
<numerator>/<denominator>  分子/分母
```
有理数在计算机科学中是非常重要的，因为他们可以像整数一样精确地表示。因此，使用有理数，原则上可以避免我们算术中的近似误差。

然而，一旦我们用分子除以分母，我们会得到一个截断的近似小数。
```
>>> 1/3
0.3333333333333333
```
> 有理数一定是精确的，无精度损失；但是如果使用有限位的小数来表示，它就是不精确的，有精度损失

这里的重要思想是通过将有理数表示为整数的比率，我们完全避免了近似问题。 因此，我们希望保持分子和分母分开，为了精确性，但把它们作为一个整体来处理。

我们从函数抽象了解，在我们开始有效的编程前，我们有实现程序的一部分。让我们假设已经有一种从分子和分母构建有理数的方式开始。我们还假设给定一个有理数，我们有一种方式提取(或选择)它的分子和分母。让我们进一步假设构造函数和选择器有以下三个函数：
- `make_rat(n, d)`，返回一个有理数，分子是`n`，分母是`d`
- `numer(x)`，返回有理数`x`的分子
- `denom(x)`，返回有理数`x`的分母

我们在这里使用了一个强大的综合策略：*一厢情愿的想法*。我们还没有说过如何表示一个有理数，或者如何实现函数`numer`，`denom`，以及`make_rat`。即使如此，如果我们有这三个函数，那么我们可以通过调用它们来进行有理数的加法、乘法、和比较相等：
```python
>>> def add_rat(x, y):
        nx, dx = numer(x), denom(x)
        ny, dy = numer(y), denom(y)
        return make_rat(nx * dy + ny * dx, dx * dy)
        
>>> def mul_rat(x, y):
        return make_rat(numer(x) * numer(y), denom(x) * denom(y))
        
>>> def eq_rat(x, y):
        return numer(x) * denom(y) == numer(y) * denom(x)
```

> 先假定函数已经有了，可以直接使用；后面再考虑如何实现

### 2.2.2 元组
为了使我们能够实现数据抽象的具体层次，Python提供了一个称为`元组`的复合结构，它可以通过用逗号分隔值来构造。 虽然不是严格要求，圆括号几乎总是围绕元组。

元组的元素可以用两种方式解包。 第一种方法是通过我们熟悉的**多重赋值**方法。事实上，多重赋值一直在创建和解包元组。第二种访问元组元素的方法是通过**索引操作符**，写作方括号。

Python中的元组(以及大多数其他编程语言中的序列)索引从0开始的，这意味着索引0选取第一个元素，索引1选取第二个元素，依此类推。索引表示的是元素距离元组开始的间隔。**也就是距离第一个元素有多远**

元素选择操作符的等价函数称为`getitem`，它也使用0索引位置从元组中选择元素。
```python
>>> from operator import getitem
>>> getitem(pair, 0)
1
```
**表示有理数**。 元组提供了一种自然的方式来实现有理数，两个整数作为一对：一个是分子，一个是分母。我们可以通过操作两个元素的元组来实现有理数的构造函数和选择器函数。

Pyhon中也内置了求两个整数的最大公约数的函数：
```python
>>> from fractions import gcd
>>> def make_rat(n, d):
        g = gcd(n, d)
        return (n//g, d//g)
```
双斜杠运算符`//`表示整除，舍去除法结果的小数部分。

**延伸阅读**。`str_rat`函数实现使用了`格式化字符串`，其中包含值的占位符。
```python
>>> def str_rat(x):
        """Return a string 'n/d' for numerator n and denominator d."""
        return '{0}/{1}'.format(numer(x), denom(x))
```

### 2.2.3 抽象栅栏
在继续更多复合数据和数据抽象的例子之前，让我们考虑一下有理数例子所提出的一些问题。我们根据构造函数`make_rat`和选择器`numer`和`denom`来定义操作。**通常，数据抽象的基本思想是为每种类型的值确定一组基本的操作，即对该类型值的所有操作进行表达，然后只使用这些运算来处理数据。**

> `only/只`：一个对象内部有数据，也有行为，要操作这个对象内部的数据，使用这个对象内已经定义好的操作就可以了，不需要再使用外部定义的函数来操作对象内部的数据。

![](http://i63.tinypic.com/1427dbb.png)

横线表示分离系统不同层次的抽象栅栏。在每个层次，栅栏将使用数据抽象的函数(上面)和实现数据抽象的函数(下面)分隔开。

在每一层，框内的函数强制规定了抽象边界，因为它们是依赖上面的表示（通过它们使用）和下面的实现（通过它们定义）的唯一函数。 这样，抽象栅栏就被表示为一系列函数集。

抽象栅栏提供了许多优点。一个好处是他们使程序更容易维护和修改。依赖于特定表示的函数越少，当表示改变时，所需的更改就越少。

> 求有理数加法改为求有理数的减法，所需修改的函数；求有理数的加法改为求无理数的加法，所需修改的函数

### 2.2.4 数据的属性
我们是从三个未指定的函数：`make_rat`、`numer`、`denom`来实现算术运算，开始实现有理数的。在这一点上，我们可以把操作看作是从数据对象（分子，分母和有理数）的角度来定义的，这些数据对象的行为是由后三个函数规定的。

但是数据到底意味着什么?仅仅说“通过给定的选择器和构造函数实现了什么”是不够的。我们需要保证这些函数一起指定正确的行为。也就是说，如果我们通过整数`n`和`d`构建了有理数`x`,然后`numer(x)/denom(x)`应该等于`n/d`。

**一般来说，我们可以认为由一些选择器和构造函数集合，以及一些行为条件来定义抽象数据类型。 只要符合行为条件（如上面的除法），这些函数就构成了数据类型的有效表示。**

我们现在可以描述二元元组的行为条件，也称为**值对**，这与表示有理数的问题有关。

如果一个值对`p`由值`x`和`y`组成，那么`getitem_pair(p, 0)`返回`x`,`getitem_pair(p, 1)`返回`y`。我们可以实现函数`make_pair`和`getitem_pair`来完成这个描述以及一个元组。
```python
>>> def make_pair(x, y):
        """Return a function that behaves like a pair."""
        def dispatch(m):
            if m == 0:
                return x
            elif m == 1:
                return y
        return dispatch
        
>>> def getitem_pair(p, i):
        """Return the element at index i of pair p."""
        return p(i)
```
这个函数表示虽然隐晦，但完全可以这样表示值对，因为它满足了值对需要满足的唯一条件。这个例子还表明，将函数当做值来操作的能力，提供给我们表示复合数据的能力。
