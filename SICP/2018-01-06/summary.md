# 1.5 控制
控制语句可能根据表达式的值来控制解释器下一步要做什么。

`break`就不是根据结果来进行下一步的语句。

## 1.5.1 语句
我们已经知道的三种语句：assignment(赋值)、`def`和`return`语句。这些Python代码它们本身不是表达式，虽然它们包含表达式作为组成部分。

强调语句的值的无意义的。我们形容语句都使用被执行而不是被求值，表达式才是被求值。每个语句都描述了一些对解释器状态的改变，执行语句来应用这些变化。正如我们看到的`return`和赋值语句，执行语句也包括对其中包含的子表达式求值。

表达式也可以被当作语句执行。
```python
>>> def square(x):
        mul(x, x) # Watch out! This call doesn't return a value.
```
在Python中这是有效的。这个函数体由一个表达式组成，表达式本身是一个有效的语句，但是这个语句的作用是调用`mul`函数，结果被丢弃。如果你想对表达式结果做些事情，你需要这么说：你可以使用赋值语句存储它，或者使用`return`语句返回它。

在最高级别，Python解释器的任务是执行由语句组成的程序。然而，许多有趣的计算工作来自于求值表达式。语句控制程序中不同表达式之间的关系以及它们的结果会怎样。

## 1.5.2 复合语句
通常，Python代码是一个语句序列。一个简单语句是单独一行，也不是冒号结束。复合语句之所以如此称呼是因为它是由其他语句组成(简单和复合)。同时，一个头和一套缩进语句被叫做一个子句。一个复合语句由一个或多个子句组成。
```
<header>:
    <statement>
    <statement>
    ...
<separating header>:
    <statement>
    <statement>
    ...
...
```
我们可以这样理解我们已经介绍过的语句的关系：
- 表达式，`return`语句和赋值语句是简单语句
- `def`语句是一个复合语句。`def`头下面的套件是定义的函数体。

每种类型头语句的专门的求值规则决定何时执行套件中的语句。

我们现在也可以理解多行程序。
- 执行一个语句序列，首先执行第一条语句。如果该语句不重定向控制，继续执行语句序列的其余部分，如果有的话。

这个定义揭示了递归定义序列的基本结构：一个序列可以被解构为它的第一个元素和其他元素。语句序列的其他元素本身也是一个语句序列。因此，我们可以递归地应用这个执行规则。 序列作为递归数据结构的视图将在后面的章节中再次出现。

这条规则的重要意义是语句要按顺序执行，但是由于重定向控制语句，可能永远不会执行到后面的语句。

实用指导：在缩进时，每行必须缩进相同的量，使用同一方式(空格，不能是制表符)。

## 1.5.3 定义函数 II：局部赋值
无论何时当用户定义的函数被应用时，其定义在套件中的子句序列都在局部环境中执行。一个`return`语句重定向控制：当第一次`return`语句执行时函数应用过程被中止，`return`表达式的值就是所应用函数的返回值。

赋值语句的作用是绑定名称到当前环境中第一个栈帧的值上。因此，在函数体中的赋值语句不能影响到全局栈帧。函数只能操纵本地环境的事实对于创建*模块化程序*至关重要，在这种模块化程序中，纯函数只能通过它们所取得和返回的值进行交互。

*模块化程序*特点：高内聚、低耦合。 功能单一，协作井然有序。功能划分清晰

其表现形式：项目中目录划分、目录中文件存放

类比计算机主机中CPU(计算模块)、内存(存储模块)、主板(总线、协作)等硬件模块。

**新环境特性**：局部赋值

## 1.5.4 条件语句
**条件语句**。Python中的条件语句由一系列的头和套件组成：一个必须的`if`子句，可选的`elif`子句序列，最后是一个可选的`else`子句。
```
if <expression>:
    <suite>
elif <expression>:
    <suite>
else:
    <suite>
```
当执行条件语句时，每个子句都按顺序考虑。
1. 对头表达式求值。
2. 如果值为真，则执行该套件中的语句。然后，跳过条件语句中所有的后续子句。

**Boolean contexts**。布尔上下文，条件块的头语句中的表达式被认为是布尔上下文：它们的真值对控制流很重要，但是它们的值永远不能被赋值或返回。Python中假的值包括：0、`None`、布尔值`False`。所有其他数字是真值。

**Boolean values**。布尔值，Python中有两个布尔值：`True`和`False`。

**Boolean operators**。布尔运算符，Python中内建了三个基本的逻辑运算符。

逻辑表达式具有相应的求值程序。 这些程序利用这样一个事实，即逻辑表达式的真值有时可以在不对其所有子表达式求值的情况下被确定，这个称为短路。

## 1.5.5 迭代
控制语句除了选择要执行的语句外，还用于表示重复。如果我们编写的每一行代码只执行一次，那么编程将是一个非常低效的活动。只有通过重复执行语句，我们才能释放计算机的潜力，使我们变得强大。我们已经看到了一种重复的形式：一个函数可以被多次应用，尽管它只被定义了一次。迭代控制结构是多次执行相同语句的另一种机制。

一个`while`子句包含一个头表达式，后面跟一套语句：
```
while <expression>:
    <suite>
```
执行`while`子句：
1. 对头表达式求值
2. 如果值为真，执行套件，然后返回到步骤1。

在步骤2中，头表达式再次求值前执行`while`子句中的全部套件。

为了防止`while`子句中的套件无限期执行，套件应该始终更改每个传递中的环境状态。

## 1.5.6 实践指南：测试
测试函数是验证函数的行为符合期望的行动。我们的函数语言现在已经足够复杂，我们需要开始测试我们的实现。

*测试*是系统地执行此验证的机制。 测试通常采用另一个函数的形式，其中包含对正在测试的函数的一个或多个示例调用。 然后将返回值与预期结果进行验证。 与大多数一般意义上的函数不同，测试涉及选择和验证带有特定参数值的调用。 测试也可以作为文档：它们演示如何调用一个函数，以及什么参数值是合适的。测试也可以充当文档：它们演示如何调用一个函数，以及什么参数值是合适的。

**Assertions**,断言，程序员使用`assert`语句来验证预期，例如测试函数输出。一个`assert`语句在布尔上下文中有一个表达式，接着是一个带引号的文本行（单引号或双引号都是正确的，但是要一致），如果表达式求值结果为假，将会显示该文本。
```
>>> assert fib(8) == 13, 'The 8th Fibonacci number should be 13'
```
当断言表达式求值结果为真时，执行断言语句没有效果。当它为假时，`assert`导致一个执行中断错误。

**Doctests**，文档测试，Python提供了一个方便的方法，将简单的测试直接放在函数的文档字符串中。文档字符串的第一行应包含函数的一行描述，随后是空行。后面可能跟随参数和行为的详细描述。 另外，文档字符串可能包含调用函数的交互式会话示例：
```
>>> def sum_naturals(n):
        """Return the sum of the first n natural numbers

        >>> sum_naturals(10)
        55
        >>> sum_naturals(100)
        5050
        """
        total, k = 0, 1
        while k <= n:
          total, k = total + k, k + 1
        return total
```
然后，可以通过`doctest`模块验证交互。 下面，`globals`函数返回全局环境的表示，解释器需要这些来求值表达式。
```
>>> from doctest import run_docstring_examples
>>> run_docstring_examples(sum_naturals, globals())
```
当在文件中编写Python时，文件中所有的文档字符串都可以使用`doctest`命令行选项启动Python来运行。
```
python3 -m doctest <python_source_file>
```
有效测试的关键是在实现新功能之后（甚至之前）立即编写（并运行）测试。 应用单一函数的测试称为*单元测试*。 详尽的单元测试是良好的程序设计的标志。

# 1.6 高阶函数
命名也是一种抽象。在CPU中计算的、在内存中存储的一定是具象的(01数值)，汇编语言中的`add`命令表示加法，是一种助记符、别名，是一种抽象

我们的程序可以计算平方，但是我们的语言缺乏表达平方概念的能力。我们应该从一个强大的编程语言中要求的事情之一就是能够通过为普通模式分配名称来构建抽象，然后直接从抽象角度进行工作。函数提供了这种能力。

我们将在下面的示例中看到，在代码中有一些常见的编程模式，但是它们与许多不同的函数一起使用。通过给它们命名，这些模式也可以被抽象出来。

为了将一些通用模式用命名的概念表达，我们需要构造可以接受其他函数作为参数或将函数作为值返回的函数。操作函数的函数被称为高阶函数。

高阶函数表达的是更高级的抽象。

## 1.6.1 函数作为参数

## 1.6.2 函数作为普通方法
这个扩展的例子说明了计算机科学中的两个相关的重要思想。首先，命名和函数使我们能够抽象出大量的复杂性。虽然每个函数的定义都是微不足道的，但是我们的求值程序所运行的计算过程看上去相当复杂，我们甚至没有说明整个过程。其次，只有这样一个事实，我们有一个非常一般的求值程序，可以把小的部件组合成复杂的过程。

## 1.6.3 定义函数 III：嵌套定义
上面的例子说明了，如何将函数作为参数传递的能力显着增强了我们编程语言的表达能力。每个一般概念或方程映射到它自己的短函数。这种编程方法的一个负面后果是全局框架变得混杂着小函数的名字。另一个问题是，我们受到特定函数签名的限制：`iter_improve`的`update`参数必须只有一个参数。在Python中，嵌套函数定义解决了这两个问题，但要求我们稍微修改一下环境模型。

**Lexical scope**,词法作用域，局部定义的函数还可以访问它们定义的作用域中的绑定名称。

我们需要对环境模型进行两个扩展来实现词法作用域：
1. 每个用户定义的函数都有一个关联的环境：定义它的环境。
2. 当调用用户定义的函数时，其局部栈帧扩展了与该函数关联的环境。

Python中词法作用域的两个关键优势：
- 局部函数的名称不会干扰定义函数的外部名称，因为局部函数名将被绑定在当前定义的局部环境中，而不是全局环境。
- 一个局部函数可以访问封闭函数的环境。这是因为局部函数体是在环境中求值的，扩展其定义的求值环境的环境。

## 1.6.4 函数作为返回值

