# 1.5 控制
控制语句可能根据表达式的值来控制解释器下一步要做什么。

`break`就不是根据结果来进行下一步的语句。

## 1.5.1 语句
我们已经知道的三种语句：assignment(赋值)、`def`和`return`语句。这些Python代码它们本身不是表达式，虽然它们包含表达式作为组成部分。

强调语句的值的无意义的。我们形容语句都使用被执行而不是被求值，表达式才是被求值。每个语句都描述了一些对解释器状态的改变，执行语句来应用这些变化。正如我们看到的`return`和赋值语句，执行语句也包括对其中包含的子表达式求值。

表达式也可以被当作语句执行。
```python
>>> def square(x):
        mul(x, x) # Watch out! This call doesn't return a value.
```
在Python中这是有效的。这个函数体由一个表达式组成，表达式本身是一个有效的语句，但是这个语句的作用是调用`mul`函数，结果被丢弃。如果你想对表达式结果做些事情，你需要这么说：你可以使用赋值语句存储它，或者使用`return`语句返回它。

在最高级别，Python解释器的任务是执行由语句组成的程序。然而，许多有趣的计算工作来自于求值表达式。语句控制程序中不同表达式之间的关系以及它们的结果会怎样。

## 1.5.2 复合语句
通常，Python代码是一个语句序列。一个简单语句是单独一行，也不是冒号结束。复合语句之所以如此称呼是因为它是由其他语句组成(简单和复合)。同时，一个头和一套缩进语句被叫做一个子句。一个复合语句由一个或多个子句组成。
```
<header>:
    <statement>
    <statement>
    ...
<separating header>:
    <statement>
    <statement>
    ...
...
```
我们可以这样理解我们已经介绍过的语句的关系：
- 表达式，`return`语句和赋值语句是简单语句
- `def`语句是一个复合语句。`def`头下面的套件是定义的函数体。

每种类型头语句的专门的求值规则决定何时执行套件中的语句。

我们现在也可以理解多行程序。
- 执行一个语句序列，首先执行第一条语句。如果该语句不重定向控制，继续执行语句序列的其余部分，如果有的话。

这个定义揭示了递归定义序列的基本结构：一个序列可以被解构为它的第一个元素和其他元素。语句序列的其他元素本身也是一个语句序列。因此，我们可以递归地应用这个执行规则。 序列作为递归数据结构的视图将在后面的章节中再次出现。

这条规则的重要意义是语句要按顺序执行，但是由于重定向控制语句，可能永远不会执行到后面的语句。

实用指导：在缩进时，每行必须缩进相同的量，使用同一方式(空格，不能是制表符)。

## 1.5.3 定义函数 II：局部赋值
无论何时当用户定义的函数被应用时，其定义在套件中的子句序列都在局部环境中执行。一个`return`语句重定向控制：当第一次`return`语句执行时函数应用过程被中止，`return`表达式的值就是所应用函数的返回值。

赋值语句的作用是绑定名称到当前环境中第一个栈帧的值上。因此，在函数体中的赋值语句不能影响到全局栈帧。函数只能操纵本地环境的事实对于创建*模块化程序*至关重要，在这种模块化程序中，纯函数只能通过它们所取得和返回的值进行交互。

*模块化程序*特点：高内聚、低耦合。 功能单一，协作井然有序。功能划分清晰

其表现形式：项目中目录划分、目录中文件存放

类比计算机主机中CPU(计算模块)、内存(存储模块)、主板(总线、协作)等硬件模块。

**新环境特性**：局部赋值

## 1.5.4 条件语句
**条件语句**。Python中的条件语句由一系列的头和套件组成：一个必须的`if`子句，可选的`elif`子句序列，最后是一个可选的`else`子句。
```
if <expression>:
    <suite>
elif <expression>:
    <suite>
else:
    <suite>
```
当执行条件语句时，每个子句都按顺序考虑。
1. 对头表达式求值。
2. 如果值为真，则执行该套件中的语句。然后，跳过条件语句中所有的后续子句。

**Boolean contexts**。布尔上下文，条件块的头语句中的表达式被认为是布尔上下文：它们的真值对控制流很重要，但是它们的值永远不能被赋值或返回。
