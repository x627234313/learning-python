# 2.5 面向对象编程
面向对象编程(OOP)是一种组织程序的方法。有下面三种特征：
- 像抽象数据类型，对象创建了抽象篱笆在数据使用和数据实现之间。
- 像在消息分发中使用字典，对象响应行为请求。
- 像可变数据结构，对象具有局部状态，局部状态不能从全局环境中直接访问。
Python对象系统提供了新的语法简化这个任务，实现所有这些有用技术来组织程序

每个对象把局部状态和行为绑定在一起，以隐藏数据抽象背后的复杂性。对象不仅仅分发消息，它们也在相同类型的其他对象间共享行为，并从相关类型中继承特性。

面向对象编程范例有自己的词汇来加强对象隐喻。**我们看到一个对象是一个数据值，具有方法和属性，通过点号访问**。每个对象也是一个类型，称为*类*。在Python中可以定义新的类，就像定义新的函数一样。

## 2.5.1 对象和类
**一个类相当于这个类中所有对象类型的模板。每个对象都是某些特定类的实例**。到目前为止，我们使用的对象都有内置的类，但是新的类可以定义，和定义新的函数类似。**一个类的定义指定了在该类的对象间共享的属性和方法**。我们将通过重新访问银行帐户的示例来引入类语句。

一个`Account`类允许我们创建多个银行帐户实例。创建一个新的对象实例的行为叫做类的*实例化*。在Python中实例化一个类的语法和调用一个函数的语法是相同的。

对象的属性是与对象关联的名称-值对，通过点号访问。特定对象的具体属性，不是类的所有对象，被称为*实例属性*。

对对象进行操作或执行对象特定计算的函数被称为方法。方法的副作用和返回值可以取决于并改变，对象的其他属性。**(调用对象)方法的返回值和副作用，是根据对象的其他属性而改变的**。
```python
>>> a.withdraw(10) # The withdraw method returns the balance after withdrawal
5>
>> a.balance # The balance attribute has changed
5>
>> a.withdraw(10)
'Insufficient funds'
```

如上所述，方法的行为可以取决于对象的变化属性。两次调用带相同参数的`withdraw`返回不同的结果。

## 2.5.2 定义类
用户定义的类通过`class`语句创建，由单个子句组成。一个类语句定义了类名和基类，然后包含一组语句来定义类的属性。
```
class <name>(<base class>):
    <suite>
```
> suite中定义的变量、方法都是类的属性。

当一个类语句被执行，一个新类被创建并绑定到`name`上，在当前环境的第一个栈帧中。然后执行`suite`。**任何名字绑定在`class`语句的`suite`中，通过`def`语句或赋值语句创建或修改类的属性**。
> 如果`suite`不执行，又怎么知道类中有这个变量或方法。执行的是类这个局部作用域中的语句。

**类通常是围绕操纵实例属性来组织的**，名称-值对不是与类本身相关联，而是与该类的每个对象相关联。**类指定它的对象的实例属性，是通过定义初始化新对象的方法**。

`class`语句中的`suite`包含`def`语句，这`def`语句是定义类对象的新方法。**在Python初始化对象的方法有一个特别的名称是`__init__`**，被称为*初始化方法*，真正的构造方法是`__new__`。

**身份检查**。每个新`account`实例有它自己的`balance`属性，它的值是独立于同一个类的其他对象。

为了强制这种分离，每个对象--用户定义类的实例，有一个唯一的身份。**对象身份是使用`is`和`is not`运算符来比较的**。

**通常，使用赋值给一个对象绑定一个新的变量名，并不会创建一个新的对象**。
```python
class Account():
    def __init__(self, holder):
        self.balance = 0
        self.holder = holder
        
a = Account("Jim")
b = Account("Jim")

>>> a is b
False
>>> c = a
>>> c is a
True
```

什么时候会创建对象？**当我们定义的类通过调用表达式语法调用时，才会实例化新对象。**

**方法**。对象方法也是由`def`语句定义的，其在`class`语句的`suite`中。

虽然方法定义在如何声明上与函数定义没有区别，但是方法定义有不同的效果。由`class`语句中的`def`语句创建的函数值绑定到声明的名称，但**在类的局部范围是作为一个属性**。这个值作为方法是从类的实例中使用点号法来调用。

**每个方法定义都包含一个特殊的第一个参数`self`，它被绑定到调用该方法的对象上。所有调用方法可以通过`self`参数访问对象，所以他们都可以访问和操纵对象的状态。**

当一个方法通过点号被调用，**这个对象本身扮演了双重角色**。首先，确定`withdraw`是什么；其次，当`withdraw`方法被调用时它绑定到第一个参数`self`上。

## 2.5.3 消息传递和点表达式
**定义在类中的方法，和通常在构造器中的实例属性，是面向对象编程的基本元素。这两个概念复制了消息传递中调度字典实现数据值的大部分行为**。对象使用点号来获取消息，但是这些消息不是任意的字符串值，而是一个类的局部名称。对象也有命名局部状态值（实例属性），但该状态可以访问并使用点号进行操作，而不必在实现中使用`nonlocal`语句。

**消息传递中的中心思想是, 数据值应该具有响应与它们所表示的抽象类型相关的消息的行为**。点号是Python的一个语法特征，它将形式化消息传递隐喻。使用具有内置对象系统的语言的优点是消息传递可以与其他语言功能（例如赋值语句）无缝地交互。我们不需要不同的消息来“get”或“set”与局部属性名称相关联的值;语言语法允许我们直接使用消息名称。

**点表达式**。
```
<expression> . <name>
```
这`expression`可以是任何有效的Python表达式，但是这`name`必须是一个简单的名称(不是计算名称的表达式)。

Python中有两个内置函数：
- `getattr`：也可以通过名称返回对象属性
- `hasattr`：测试对象是否有一个命名的属性
```python
>>> getattr(tom_account, 'balance')
10
>>> hasattr(tom_account, 'deposit')
True
```
对象的属性包括其所有实例属性，以及其类中定义的所有属性（包括方法）。方法是需要特殊处理的类的属性。

**方法和函数**，当对象调用方法时，这个对象就绑定到方法的第一个参数`self`上。

我们可以在点表达式的返回值上使用`type`函数来看到不同。**作为类的属性，仅仅是一个函数；但是作为实例的属性，它是方法**。
```python
>>> type(Account.deposit)
<class 'function'>
>>> type(tom_account.deposit)
<class 'method'>
```

> - 实例方法：被类的实例所拥有
> - `@staticmethod`：可以被所有实例调用，也能被类调用，其内的计算过程和实例无关。只是作为普通函数
> - `@classmethod`：被所有的实例共用。它的状态和类相关，和实例无关
```python
>>> class Test():
...   def a(self):
...     pass
...
...   @staticmethod
...   def b(self):
...     pass
...
...   @classmethod
...   def c(cls):
...     pass
...
>>> Test.a
<function Test.a at 0x000002ACDDF6FA60>
>>> Test().a
<bound method Test.a of <__main__.Test object at 0x000002ACDDF756D8>>
>>> Test.b
<function Test.b at 0x000002ACDDF6FAE8>
>>> Test().b
<function Test.b at 0x000002ACDDF6FAE8>
>>> Test.c
<bound method Test.c of <class '__main__.Test'>>
>>> Test().c
<bound method Test.c of <class '__main__.Test'>>
```

**调用类中方法有两种方式**：  
- 作为函数调用，传参时要请注意，第一个参数是类的实例
```python
>>> Account.deposit(tom_account, 1001) # The deposit function requires 2 arguments
1011
```
- 作为方法调用，对象通过点号调用方法
```python
>>> tom_account.deposit(1000) # The deposit method takes 1 argument
2011
```

**实践指南：命名风格**  
[PYTHON编码规范.pdf]()

## 2.5.4 类属性
定义在类的里面，方法的外面，所有对象共享。`interest`就是类属性。
```python
class Account(object):
    interest = 0.02 # A class attribute
    def __init__(self, account_holder):
        self.balance = 0
        self.holder = account_holder
    # Additional methods would be defined here
```

这个属性可以被类的任何实例访问。但是使用类名对这个属性赋值，所有实例的属性值都会改变。
```
>>> Account.interest = 0.04
>>> tom_account.interest
0.04
>>> jim_account.interest
0.04
```

**属性名称**
正如我们所看到的，一个点表达式由一个表达式、一个点号和一个名称组成:
```
<expression> . <name>
```
点号表达式求值的过程：
1. 求出点号左边表达式的值，它是可以产出*object*的表达式。
2. `name`是否在这个对象中；如果属性存在，返回它的值。
3. 如果不存在，向上层的类中去查找
4. 然后返回这个值除非它是一个函数，这种情况返回方法

在这个求值过程中，实例属性是在类属性之前查找，就像在环境中局部名称优先于全局名称。

**赋值**。如果是实例变量，赋值语句影响的是这个实例，对别的实例没有影响；如果是类变量，赋值语句会影响到所有的实例。

## 2.5.5 继承
在OOP范式中工作时，我们经常发现不同的抽象数据类型是相关的。特别是，我们发现相似的类在专业化程度上有所不同。**两个类可能有相似的属性，但其中一个是另一个的特例**。

`CheckingAccount`是`Account`的专业化。`Account`就作为`CheckingAccount`的**基类**，`CheckingAccount`就是`Account`的子类。术语*父类*和*超类*也是基类，*子类*就是子类。

子类继承其基类的属性，但可能会**重载**(override)某些属性，包括某些方法。**通过继承，我们只指定子类和基类之间的区别。任何我们在子类中未指定的东西都会被自动假定为和基类一样的行为。**

继承除了是一个有用的组织特征，也是我们对象隐喻的一个角色。继承表示类之间`*is-a*`的关系，和`*has-a*`关系形成对比。

> `学生`是`人`；`人`有眼、耳、口、鼻

## 2.5.6 使用继承
我们通过将基类放在类名后面的圆括号中来指定继承。

当Python解析点表达式中不是实例属性的名称是，它会在类中查找。实际上，它会去继承链里每个基类中查找。


## 2.5.7 多继承
Python中，类有个`__mro__`属性，解析继承的顺序。
```python
class AsSeenOnTVAccount(CheckingAccount, SavingsAccount):
    def __init__(self, account_holder):
        self.holder = account_holder
        self.balance = 1
```
如果实例属性只在一个类中存在，引用是明确的；如果在多个类中存在，引用就是模糊的，不明确的。

Python解析名称是从左到右，向上。(根据继承时基类的位置，从左向右解析)

继承顺序问题没有正确的解决方案，因为在某些情况下，我们可能宁愿优先考虑某些继承类。但是，**任何支持多继承的编程语言都必须以一致的方式选择一些排序**，以便该语言的用户可以预测其程序的行为。

## 2.5.8 对象的角色
Python对象系统的设计使数据抽象和消息传递既方便又灵活。类，方法，继承和点表达式的专门语法使我们能够在程序中形式化对象隐喻，这提高了我们组织大型程序的能力。

特别是，我们希望我们的对象系统能够在程序的不同方面促进*关注分离*。程序中的每个对象封装和管理程序状态的一部分，每个类语句定义了实现程序总体逻辑某些部分的函数。抽象篱笆强化了大型程序不同方面之间的界限。

面向对象编程特别适用于具有独立部分但相互依赖的模型系统的程序。

另一方面，类可能没有提供实现某些抽象的最佳机制。而函数抽象提供了表示输入输出关系的更自然的隐喻。函数还可以强制分离关注点。

像Python这样的多范式语言允许程序员将组织范例与适当的问题相匹配。学习什么时候引入一个新的类，而不是一个新的函数，以便简化或模块化一个程序，在软件工程中是值得关注的重要设计技能。
