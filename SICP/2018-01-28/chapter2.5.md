# 2.5 面向对象编程
面向对象编程(OOP)是一种组织程序的方法。有下面三种特征：
- 像抽象数据类型，对象创建了抽象篱笆在数据使用和数据实现之间。
- 像在消息分发中使用字典，对象响应行为请求。
- 像可变数据结构，对象具有局部状态，局部状态不能从全局环境中直接访问。
Python对象系统提供了新的语法简化这个任务，实现所有这些有用技术来组织程序

每个对象把局部状态和行为绑定在一起，以隐藏数据抽象背后的复杂性。对象不仅仅分发消息，它们也在相同类型的其他对象间共享行为，并从相关类型中继承特性。

面向对象编程范例有自己的词汇来加强对象隐喻。**我们看到一个对象是一个数据值，具有方法和属性，通过点号访问**。每个对象也是一个类型，称为*类*。在Python中可以定义新的类，就像定义新的函数一样。

## 2.5.1 对象和类
**一个类相当于这个类中所有对象类型的模板。每个对象都是某些特定类的实例**。到目前为止，我们使用的对象都有内置的类，但是新的类可以定义，和定义新的函数类似。**一个类的定义指定了在该类的对象间共享的属性和方法**。我们将通过重新访问银行帐户的示例来引入类语句。

一个`Account`类允许我们创建多个银行帐户实例。创建一个新的对象实例的行为叫做类的*实例化*。在Python中实例化一个类的语法和调用一个函数的语法是相同的。

对象的属性是与对象关联的名称-值对，通过点号访问。特定对象的具体属性，不是类的所有对象，被称为*实例属性*。

对对象进行操作或执行对象特定计算的函数被称为方法。方法的副作用和返回值可以取决于并改变，对象的其他属性。**(调用对象)方法的返回值和副作用，是根据对象的其他属性而改变的**。
```python
>>> a.withdraw(10) # The withdraw method returns the balance after withdrawal
5>
>> a.balance # The balance attribute has changed
5>
>> a.withdraw(10)
'Insufficient funds'
```

如上所述，方法的行为可以取决于对象的变化属性。两次调用带相同参数的`withdraw`返回不同的结果。

## 2.5.2 定义类
用户定义的类通过`class`语句创建，由单个子句组成。一个类语句定义了类名和基类，然后包含一组语句来定义类的属性。
```
class <name>(<base class>):
    <suite>
```
> suite中定义的变量、方法都是类的属性。

当一个类语句被执行，一个新类被创建并绑定到`name`上，在当前环境的第一个栈帧中。然后执行`suite`。**任何名字绑定在`class`语句的`suite`中，通过`def`语句或赋值语句创建或修改类的属性**。
> 如果`suite`不执行，又怎么知道类中有这个变量或方法。执行的是类这个局部作用域中的语句。

**类通常是围绕操纵实例属性来组织的**，名称-值对不是与类本身相关联，而是与该类的每个对象相关联。**类指定它的对象的实例属性，是通过定义初始化新对象的方法**。

`class`语句中的`suite`包含`def`语句，这`def`语句是定义类对象的新方法。**在Python初始化对象的方法有一个特别的名称是`__init__`**，被称为*初始化方法*，真正的构造方法是`__new__`。

**身份检查**。每个新`account`实例有它自己的`balance`属性，它的值是独立于同一个类的其他对象。

为了强制这种分离，每个对象--用户定义类的实例，有一个唯一的身份。**对象身份是使用`is`和`is not`运算符来比较的**。

**通常，使用赋值给一个对象绑定一个新的变量名，并不会创建一个新的对象**。
```python
class Account():
    def __init__(self, holder):
        self.balance = 0
        self.holder = holder
        
a = Account("Jim")
b = Account("Jim")

>>> a is b
False
>>> c = a
>>> c is a
True
```

什么时候会创建对象？**当我们定义的类通过调用表达式语法调用时，才会实例化新对象。**

**方法**。对象方法也是由`def`语句定义的，其在`class`语句的`suite`中。

虽然方法定义在如何声明上与函数定义没有区别，但是方法定义有不同的效果。由`class`语句中的`def`语句创建的函数值绑定到声明的名称，但**在类的局部范围是作为一个属性**。这个值作为方法是从类的实例中使用点号法来调用。

**每个方法定义都包含一个特殊的第一个参数`self`，它被绑定到调用该方法的对象上。所有调用方法可以通过`self`参数访问对象，所以他们都可以访问和操纵对象的状态。**

当一个方法通过点号被调用，**这个对象本身扮演了双重角色**。首先，确定`withdraw`是什么；其次，当`withdraw`方法被调用时它绑定到第一个参数`self`上。

## 2.5.3 消息传递和点表达式
**定义在类中的方法，和通常在构造器中的实例属性，是面向对象编程的基本元素。这两个概念复制了消息传递中调度字典实现数据值的大部分行为**。对象使用点号来获取消息，但是这些消息不是任意的字符串值，而是一个类的局部名称。对象也有命名局部状态值（实例属性），但该状态可以访问并使用点号进行操作，而不必在实现中使用`nonlocal`语句。

**消息传递中的中心思想是, 数据值应该具有响应与它们所表示的抽象类型相关的消息的行为**。点号是Python的一个语法特征，它将形式化消息传递隐喻。使用具有内置对象系统的语言的优点是消息传递可以与其他语言功能（例如赋值语句）无缝地交互。我们不需要不同的消息来“get”或“set”与局部属性名称相关联的值;语言语法允许我们直接使用消息名称。

**点表达式**。
```
<expression> . <name>
```
这`expression`可以是任何有效的Python表达式，但是这`name`必须是一个简单的名称(不是计算名称的表达式)。

Python中有两个内置函数：
- `getattr`：也可以通过名称返回对象属性
- `hasattr`：测试对象是否有一个命名的属性
```python
>>> getattr(tom_account, 'balance')
10
>>> hasattr(tom_account, 'deposit')
True
```
对象的属性包括其所有实例属性，以及其类中定义的所有属性（包括方法）。方法是需要特殊处理的类的属性。

**方法和函数**，当对象调用方法时，这个对象就绑定到方法的第一个参数`self`上。

我们可以在点表达式的返回值上使用`type`函数来看到不同。**作为类的属性，仅仅是一个函数；但是作为实例的属性，它是方法**。
```python
>>> type(Account.deposit)
<class 'function'>
>>> type(tom_account.deposit)
<class 'method'>
```

> - 实例方法：被类的实例所拥有
> - `@staticmethod`：可以被所有实例调用，也能被类调用，其内的计算过程和实例无关。只是作为普通函数
> - `@classmethod`：被所有的实例共用。它的状态和类相关，和实例无关
```python
>>> class Test():
...   def a(self):
...     pass
...
...   @staticmethod
...   def b(self):
...     pass
...
...   @classmethod
...   def c(cls):
...     pass
...
>>> Test.a
<function Test.a at 0x000002ACDDF6FA60>
>>> Test().a
<bound method Test.a of <__main__.Test object at 0x000002ACDDF756D8>>
>>> Test.b
<function Test.b at 0x000002ACDDF6FAE8>
>>> Test().b
<function Test.b at 0x000002ACDDF6FAE8>
>>> Test.c
<bound method Test.c of <class '__main__.Test'>>
>>> Test().c
<bound method Test.c of <class '__main__.Test'>>
```

**调用类中方法有两种方式**：  
- 作为函数调用，传参时要请注意，第一个参数是类的实例
```python
>>> Account.deposit(tom_account, 1001) # The deposit function requires 2 arguments
1011
```
- 作为方法调用，对象通过点号调用方法
```python
>>> tom_account.deposit(1000) # The deposit method takes 1 argument
2011
```

**实践指南：命名风格**  
[PYTHON编码规范.pdf]()

## 2.5.4 类属性
定义在类的里面，方法的外面












































