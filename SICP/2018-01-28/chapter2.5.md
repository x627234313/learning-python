# 2.5 面向对象编程
面向对象编程(OOP)是一种组织程序的方法。有下面三种特征：
- 像抽象数据类型，对象创建了抽象篱笆在数据使用和数据实现之间。
- 像在消息分发中使用字典，对象响应行为请求。
- 像可变数据结构，对象具有局部状态，局部状态不能从全局环境中直接访问。
Python对象系统提供了新的语法简化这个任务，实现所有这些有用技术来组织程序

每个对象把局部状态和行为绑定在一起，以隐藏数据抽象背后的复杂性。对象不仅仅分发消息，它们也在相同类型的其他对象间共享行为，并从相关类型中继承特性。

面向对象编程范例有自己的词汇来加强对象隐喻。**我们看到一个对象是一个数据值，具有方法和属性，通过点号访问**。每个对象也是一个类型，称为*类*。在Python中可以定义新的类，就像定义新的函数一样。

## 2.5.1 对象和类
**一个类相当于这个类中所有对象类型的模板。每个对象都是某些特定类的实例**。到目前为止，我们使用的对象都有内置的类，但是新的类可以定义，和定义新的函数类似。**一个类的定义指定了在该类的对象间共享的属性和方法**。我们将通过重新访问银行帐户的示例来引入类语句。

一个`Account`类允许我们创建多个银行帐户实例。创建一个新的对象实例的行为叫做类的*实例化*。在Python中实例化一个类的语法和调用一个函数的语法是相同的。

对象的属性是与对象关联的名称-值对，通过点号访问。特定对象的具体属性，不是类的所有对象，被称为*实例属性*。

对对象进行操作或执行对象特定计算的函数被称为方法。方法的副作用和返回值可以取决于并改变，对象的其他属性。**(调用对象)方法的返回值和副作用，是根据对象的其他属性而改变的**。
```python
>>> a.withdraw(10) # The withdraw method returns the balance after withdrawal
5>
>> a.balance # The balance attribute has changed
5>
>> a.withdraw(10)
'Insufficient funds'
```

如上所述，方法的行为可以取决于对象的变化属性。两次调用带相同参数的`withdraw`返回不同的结果。

## 2.5.2 定义类
用户定义的类通过`class`语句创建，由单个子句组成。一个类语句定义了类名和基类，然后包含一组语句来定义类的属性。
```
class <name>(<base class>):
    <suite>
```
> suite中定义的变量、方法都是类的属性。

当一个类语句被执行，一个新类被创建并绑定到`name`上，在当前环境的第一个栈帧中。然后执行`suite`。**任何名字绑定在`class`语句的`suite`中，通过`def`语句或赋值语句创建或修改类的属性**。
> 如果`suite`不执行，又怎么知道类中有这个变量或方法。执行的是类这个局部作用域中的语句。

**类通常是围绕操纵实例属性来组织的**，名称-值对不是与类本身相关联，而是与该类的每个对象相关联。**类指定它的对象的实例属性，是通过定义初始化新对象的方法**。

`class`语句中的`suite`包含`def`语句，这`def`语句是定义类对象的新方法。**在Python初始化对象的方法有一个特别的名称是`__init__`**，被称为*初始化方法*，真正的构造方法是`__new__`。

**身份检查**。每个新`account`实例有它自己的`balance`属性，它的值是独立于同一个类的其他对象。

为了强制这种分离，每个对象--用户定义类的实例，有一个唯一的身份。**对象身份是使用`is`和`is not`运算符来比较的**。

**通常，使用赋值给一个对象绑定一个新的变量名，并不会创建一个新的对象**。
```python
class Account():
    def __init__(self, holder):
        self.balance = 0
        self.holder = holder
        
a = Account("Jim")
b = Account("Jim")

>>> a is b
False
>>> c = a
>>> c is a
True
```

什么时候会创建对象？**当我们定义的类通过调用表达式语法调用时，才会实例化新对象。**

**方法**。对象方法也是由`def`语句定义的，其在`class`语句的`suite`中。







## 2.5.3 消息分发和点表达式
