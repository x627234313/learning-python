# 1.3.1 环境
一个求值表达式的环境由一系列的栈帧组成。每个栈帧都包含绑定，这些绑定将一个名称与其相应的值相关联。

赋值和导入语句添加条目到当前环境的第一个栈帧中。 到目前为止，我们的环境只包含全局栈帧。

一个`def`语句也绑定一个名称到定义时创建的函数上。

![1.3.1](http://i66.tinypic.com/10p6hqw.png)

注意函数的名称是可重复的，一次是栈帧中，一次作为函数本身的一部分。这种重复是故意的：许多不同的名称可能指向相同的函数，但是函数本身只有一个内部名称。
但是，在环境中查找名称的值只会检查名称绑定。 函数的内部名称在查找名称时不起作用。

__New environment Features__：Assignment and user-defined function definition.  
（assignment：分配 任务 作业）  
新环境特点：赋值和用户定义的函数定义。

# 1.3.2 调用用户定义的函数
求值一个调用表达式，其运算符命名用户定义的函数，Python解释器按照相似的过程对于使用内建运算符函数求值的表达式。也就是说，解释器对操作数表达式求值，然后将命名函数应用到结果参数。

应用用户定义函数的行为引入了第二个本地栈帧，这个栈帧只能被该函数访问。应用用户定义函数的一些理由：
1. 将参数绑定到新的本地栈帧中函数形参的名称上
2. 从该栈帧开始到全局栈帧结束，在这个环境中求函数体的值。

求值主体的环境由两个栈帧组成：首先是本地栈帧包含参数绑定，然后是全局栈帧包含其他所有内容。 函数应用程序的每个实例都有自己独立的本地栈帧。

![1.3.2](http://i64.tinypic.com/6rh6zd.png)

这个图包含了Python解释器的两个不同方面：当前的环境，以及与正在求值的当前代码行相关的表达式树的一部分。 我们已经描述了一个调用表达式的求值，它有用户定义的函数（蓝色部分）作为两部分圆角矩形。 虚线箭头表示哪个环境被用于每个部分的求值表达式。
- 蓝色的上半部分显示正在求值的调用表达式。这个调用表达式不是任何函数的内部，所以它在全局环境中求值。 因此，在全局栈帧中查找其中的任何名称（例如`square`）。
- 蓝色的下半部分显示了`square`函数的主体。它的返回表达式是在上面第一步引入新环境时计算的，绑定`square`的形参名`x`到参数值`-2`上。

环境中栈帧的顺序影响在表达式中查找名称的返回值。我们之前说过当前环境的名称与该名称计算的值是相关联的。我们现在可以更准确的说：
- 一个名称计算的值绑定到当前环境最早的栈帧中被找到的该名称上。

我们的环境，名称和函数概念上的栈帧构成了一个求值模型; 虽然一些细节没有明确规定（例如，绑定是如何实现的），但是我们的模型能够准确地描述解释器如何计算调用表达式。 在第3章中，我们将看到这个模型如何作为实现编程语言的工作解释器的蓝图。

__新的环境特性__：函数应用。

# 1.3.3 示例：调用用户定义的函数
重新考虑两个简单的定义：
```python
from operator import add, mul

def square(x):
    return mul(x, x)
    
def sum_squares(x, y):
    return add(square(x), square(y))
```

![](http://i66.tinypic.com/11u98ph.png)

和调用表达式的求值过程：`sum_squares(5, 12)`

Python首先计算名称`sum_squares`，它是绑定到全局栈帧中的用户定义函数。计算原始数值表达式5和12代表的数字。

下一步，Python调用`sum_squares`,引入本地栈帧x绑定5，y绑定12。

![](http://i63.tinypic.com/jz8dwi.png)

在该图中，本地栈帧指向其继承者，全局栈帧。 所有本地帧必须指向一个前任，这些链接定义了当前环境的帧序列。

`sum_squares`的主体包含这个调用表达式。

![](http://i63.tinypic.com/wafupd.png)

运算符子表达式`add`在全局栈帧中查找，绑定到内置的加法函数。在使用加法前，必须依次计算两个操作数子表达式。在下图中，这个本地栈帧记为`A`,同样使用标签`A`替换指向这个栈帧的箭头。

在`operand 0`中，`square`是全局栈帧中用户定义的函数，而`x`在本地栈帧是5。Python通过引入另一个x绑定到5的本地栈帧来调用`square(5)`。

![](http://i67.tinypic.com/b6tyqr.png)

使用这个局部栈帧，`mul(x, x)`计算结果是25。

计算过程转到`operand 1`时，Python又一次计算`square`的主体，又一次引入另一个局部框架x绑定到12。`operand 1`计算结果是144。

![](http://i65.tinypic.com/2pyp4dg.png)

这个图说明了许多开发的基本思想。名称绑定到值，这些值分布在许多局部栈帧中，这些栈帧位于一个包含共享名称的全局栈帧之前。表达式是树状结构的，而且每当子表达式包含对用户定义的函数调用时，环境必须被扩充。

所有这些机制的存在是为了确保名称在表达式树的正确位置上解析为正确的值。

# 1.3.4 本地名称
函数的形参应该和函数的实现无关。最简单的结果是函数形参名称必须保持在本地的函数体上。

`square`函数中的`x`和`sum_squares`函数中的`x`是不会混淆的，因为在不同的本地栈帧中绑定的`x`是不相关的。我们的计算模型是精心设计的以确保这种独立性。

本地名称的_作用域_被限制在定义它的用户定义的函数体中。当一个名称不再可用时，它就超出了范围。这种界定行为不是模型的原因，而是环境工作的结果。

# 1.3.5 实用指南：选择名称
形参的名称不是无关紧要的。相反我们选择函数和形参名称对人们解释函数定义是至关重要的。

一些共同遵守的约定使编程社区成员间的交流更顺利，另一方面你也会发现你的代码变得内部更加一致：
1. 函数名称应该是小写，用下划线分隔。 描述性的名称是被鼓励的。
2. 函数的名称通常能说明由解释器应用于参数的操作（例如，print，add，square）或从一些数量的名称中得到结果（例如，max，abs，sum）。
3. 参数名称应该是小写的，用下划线分隔。 单词名是首选。
4. 参数的名称应该能显示函数中参数的作用，而不仅仅是被允许的数值类型。
5. 单个字母的参数名称是被允许的，当它们的作用显而易见时。但是不能使用"l"(小写的l)、"O"(大写的O)、"I"(大写的I)等容易与数字混淆的字母。

# 1.3.6 作为抽象函数
`sum_squares`函数虽然是根据`square`定义的，但是它只依赖于`square`定义时输入的参数和输出的值。

我们可以直接写`sum_squares`函数而不用亲自关心如何计算一个数的平方。事实上，对`sum_squares`而言，`square`不是一个特定的函数体，而是一个抽象的函数，即所谓的抽象函数。在这个抽象层次，任何计算平方的函数都是一样的。

这样，只考虑返回值，下面的两个函数应该是不能区分的：
```Python
def square(x):
    return mul(x, x)

def square(x):
    return mul(x, x-1) + x
```
换句话说，一个函数的定义应该能屏蔽细节。函数使用者可能没有编写函数，但是可能从另一个程序员那里获得了它作为一个“黑盒”。用户为了使用它不需要知道该如何实现。就像使用Python库一样。

# 1.3.7 运算符
带有中缀运算符的Python表达式都有自己的求值过程，但是可以将它们看作调用表达式的缩写。例如：
``` Python
2 + 5
```
简单的认为它的缩写是：
```Python
add(2, 3)
```
中缀符号是可以嵌套。Python应用正常的数学规则中的运算符优先级：
```python
2 + 3 * 4 + 5
```
相当于
```Python
add(add(2, mul(3, 4)) , 5)
```
调用表达式中的嵌套比操作符版本更加明确。 Python还允许子表达式用圆括号分组，以覆盖正常的优先规则或使表达式的嵌套结构更加明确。
```python
(2 + 3) * (4 + 5)
```
与求值结果相同
```python
mul(add(2, 3), add(4, 5))
```
你应该随时在你的程序中使用这些运算符和括号。在简单的数学运算中Python更喜欢使用运算符。
