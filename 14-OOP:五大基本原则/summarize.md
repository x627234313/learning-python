# SOLID
- Single responsibility principle
- Open/closed principle
- Liskov substitution principle
- Interface segregation principle
- Dependency inversion principle

## 单一职责
对象应该具有单一的功能。换句话说，一个对象、接口或模块，应突出主要功能，最好只有一个功能。

分清楚“必须做”和“可以做”的事情。每个角色做好必须做的事情。如果还有一些事情没人做，那就创造角色让他去做。

对象就是类的实例，每个对象在它所处的级别功能是单一的。如果在函数级别，没有满足单一职责就不一定满足得了开闭原则。

## 开闭原则
软件体对扩展是开放的，但对修改是封闭的。

通过预留的接口或超前一点的设计，可以很容易添加新的功能；软件体是相对封闭的，当想要修改的时候，应该是修改它的内部，而不会影响到外部行为。

## 里氏替换
程序中的对象应该是可以在不改变程序正确性的前提下被它的子类对象所替换的。

## 接口隔离
多个特定客户端的接口要好于一个宽泛用途的接口。

## 依赖反转
高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口；  
抽象接口不应该依赖于具体实现，而具体实现则应该依赖于抽象接口。

为了理解这个原则，先要明白几个与之相关而又容易混淆的概念：__依赖注入(Dependency Injection)__、__控制反转(Inversion of control)__

反转即方向相反。依赖关系是有方向性的，控制关系也是有方向性的。反转之前的正常方向是如何确定的呢？是根据__结构化分析与设计技术(SADT)__而来。

SADT:简言之是一种自顶向下的拆分设计方法，把一个大问题A(设计一个大的模块A)，拆分为三个小问题(子模块)B、C、D，正常方式是A依赖于(或调用)B、C、D，这个过程反过来就是反转

#### 依赖注入
依赖注入是关于一个对象是如何获取依赖的，常见的注入方法有：构造器注入、Setter注入、接口注入。

若A依赖于B，不让A调用B，而是把B传递给A，使之成为A的一部分，这就是依赖注入。

依赖注入是实现依赖反转的一种方法，还可以通过服务定位模式、插件模式等实现依赖反转。

#### 控制反转
控制反转是关于谁发出调用的，即程序控制权、自主权的转变。如果你写的代码发起了调用，不是控制反转；反之，一个容器/系统/框架，调用了你提供给它的代码，就是控制反转。

控制反转是构架(framework)和库(library)的关键区别。库本质上是一组供你调用的函数或类，每个调用完成之后，都会将控制权交回给调用者；而框架侧重于抽象设计，有更多的内置行为，为了使用框架，你需要子类化或插件化地提供自己的代码，这些代码被嵌入框架的各个地方，然后框架调用你写的代码。

#### 依赖反转
依赖反转主要目的是为了将高层模块对底层模块的依赖解耦，使得替换低层模块变得容易。

并不是说让高层依赖低层变成了低层依赖高层，而是让高层与低层都依赖于抽象。

换言之，依赖反转就是在高层和低层之间增加抽象层，而且这个抽象层是由高层定义的。

##
