# HTTP（HyperText Transfer Protocol）
HTTP：超文本转移协议。

它是基于TCP/IP的应用层协议，默认使用80端口，HTTPS是443端口。使用C/S架构，Client端由浏览器(Browser)实现,又称B/S架构，Server端提供超文本(已发展为超媒体)服务。只能由Client主动发起请求，Server端再返回响应。

## HTTP/1.0
1991年发布的HTTP/0.9版本功能非常简单，只有一个GET方法，服务器也只能返回HTML格式的字符串。

1996年HTTP/1.0发布，增加了很多功能。可以传输任何格式的内容；增加了POST、HEAD方法；请求和响应内容必须包含头信息；状态码(status code)；内容编码(content encoding)等。
1. 请求格式  
   ```
   GET / HTTP/1.0
   User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
   Accept: */*
   CRLF
   ```
   第一行是请求行，以CRLF结尾；下面是多行头信息，以CRLF结尾；下面是一个空行；最后是请求数据(也可为空)。
2. Content-Type字段  
   HTTP/1.0规定，头信息必须是ASCII码，后面的数据可以是任何格式。因此服务器必须告诉客户端响应的内容是什么类型，就是Content-Type的作用。
   
   常见的Content-Type的值：
   `text/html、text/plain、text/css、image/png、image/jpeg、audio/mp4、video/mp4、application/pdf、application/zip`
   这些类型总称为`MIME Type`。
   
   客户端请求也可以使用`Accpet`字段声明自己可以接收哪些数据类型。
   `Accpet: */*` 可以接收任何类型的数据。
3. Content-Encoding字段  
   由于可以发送任何类型的数据，因此可以把数据压缩后再发送，Content-Encoding字段说明压缩的方法。
   ```
   Content-Encoding: gzip
   Content-Encoding: compress
   ```
   客户端使用Accept-Encoding字段说明可以接受哪些压缩方法：
   ```
   Accept-Encoding: gzip, deflate
   ```
4. 缺点  
   HTTP/1.0主要缺点是每个TCP连接只能发送一次请求和响应，数据发送完成就关闭连接。因此每次请求都要重新建立TCP连接，增加了开销，导致HTTP/1.0性能较差。

## HTTP/1.1
1997年1月，HTTP/1.1发布，只比HTTP/1.0晚了半年。

1. 持久连接  
   为了解决每次请求都要建立TCP连接的问题，HTTP/1.1和一部分HTTP/1.0想出了持久连接(HTTP Persistent Connections,也称HTTP keep-alive或HTTP            Connection Reuse)的方法。即只要任意一端没有明确提出断开连接，则保持TCP连接状态。

2. 管线化(pipelining)  
   HTTP/1.1还引入的管线化机制。即在一个TCP连接中，客户端可以同时发送多个请求。虽然可以同时发送多个请求，但是服务器也要按照请求顺序依次发送响应。
   
3. 分块传输编码(Chunked transfer encoding)  
   通常，HTTP应答消息中发送的数据是整个发送的，Content-Length消息头字段表示数据的长度。数据的长度很重要，因为客户端需要知道哪里是应答消息的结束，以   及后续应答消息的开始。
   
   然而，使用分块传输编码，数据分解成一系列数据块，并以一个或多个块发送，这样服务器可以发送数据而不需要预先知道发送内容的总大小。通常数据块的大小是一    致的，但也不总是这种情况。
   
   如果一个HTTP消息（请求消息或应答消息）的Transfer-Encoding消息头的值为chunked，那么，消息体由数量未定的块组成，并以最后一个大小为0的块为结束。
   
4. 缺点  
   虽然HTTP/1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个请求，才会进行下一个请求。要是前面的请求处理的特别慢，后面就会有许多请求排队等着。这称为"队头阻塞"（Head-of-line blocking）。
   
## HTTP的缺点和瓶颈
1. 安全性
   - 基于明文，通信内容可能被窃听。
   - 不验证通信双方的身份，可能一方是伪装的。
   - 无法证明报文完整性，内容可能被篡改。
2. 性能
   - 一条TCP连接上只能发送一个请求
   - 队头阻塞
   - 请求只能由客户端发起，客户端不可接受响应之外的指令
   - 请求和响应头部未压缩，头部信息越多延迟越大
   - 发送冗长的头部，来回之间如果头部大部分字段未改变，浪费资源
   - 可选择任意压缩格式，不强制压缩后发送

## HTTP/2
2015年，HTTP/2发布，它不叫HTTP/2.0是因为标准委员会不准备发布子版本。HTTP/2主要解决了HTTP/1.1效率不高的问题。对比HTTP/1.1，它的主要特性有：
1. 二进制分帧  
HTTP/1.1版的头信息是文本格式，数据体可以是文本，也可以是二进制的。HTTP/2中头信息和数据体都是二进制，统称为“帧”(frame):头信息帧和数据帧。
2. 多路复用/多工  
   每个客户端与服务器间只建立一个TCP连接，只要没有哪端明确提出关闭，就可以被多次请求复用。

   客户端和服务器可以把HTTP消息分解为相互独立的帧，交错发送，不用按照顺序一一对应，这样避免了“队头阻塞”。
3. 数据流  
   HTTP/2将每个请求或响应的所有数据包称为一个数据流(stream)，每个数据流都有一个唯一编号，数据包发送时都要标记数据流ID。数据流是一个逻辑上的概念，因    为可以同时请求或响应多次，每个数据流的帧可能不会连续发送，而是根据数据流ID把每个帧组合起来。

   客户端还可以指定数据流的优先级，服务器根据优先级分配资源，决定处理顺序。

4. 服务器推送  
   HTTP/2允许服务器对一个客户端请求，发送多个响应。

   常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其   实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。

5. 头部压缩  
   HTTP协议是无状态的，每次请求都必须附上所有信息，所以，请求的很多字段都是重复的，比如Cookie和User Agent，这会浪费很多带宽，也影响速度。

   HTTP/2通过静态 Huffman 代码对传输的标头字段进行编码，从而减小了各个传输的大小。另一方面要求客户端和服务器同时维护和更新一个包含之前见过的标头字段    的索引列表，对之前传输的值进行有效编码。

# SSL vs TLS
TLS和其前身SSL都是一种安全协议，目的是为网络通信提供安全认证和数据加密。

1995年，SSL 2.0首次发布，但是因为存在严重的安全漏洞被1996年发布的SSL 3.0 替代。IETF将SSL标准化，并将其称为TLS，基于SSL3.0。

> “它与SSL 3.0之间的差异并不明显，但却足够重要，使TLS 1.0和SSL 3.0不会互操作”

在2011和2015年，IEFT分别弃用了SSL 2.0 和SSL 3.0，过去几年一直有漏洞被发现。Google、Mozilla也在其发布的浏览器中禁用了SSL 3.0，强制使用TLS协议。

# RESTful HTTP API
Representational State Transfer (REST)：是一种基于HTTP定义的一组约束和属性的架构风格。它是一种Web服务的设计原则而非标准，符合REST风格的Web服务提供了客户端和服务器间的互操作性，也允许客户端使用统一和预定义的一组无状态的操作来访问和操纵Web资源。

Web资源最初在万维网上定义为由URL(统一资源定位符)标识的文档或文件，现在更通用和抽象的定义是，Web上可以被定义、命名、访问、处理的任何实体。每种资源可以对应一种URI(统一资源标识符)。在REST风格的Web服务中，对资源URI的请求会引起HTML、XML、JSON或其他格式的响应。响应可以确认对存储资源的修改，也提供了其他相关资源的超链接。当使用HTTP时，常用的操作是GET(获取)、POST(创建)、PUT(更新)、DELETE(删除)和其他定义的CRUD HTTP方法。

URL和URN都可以看作是URI，URN提供了一个实体名称，URL提供了找到这个实体的方法。URN就像一个人的名字，URL就是这个人的地址。

遵循REST架构约束的Web服务API称为RESTful API。它定义了以下几个方面：
1. 基本的URL,`http://api.example.com/resources` ，也可以简单的把API放到主域名下`https://example.com/api/v1` 。
2. 定义状态转换数据元素的媒体类型。JSON因为它的可读性、紧凑性及多种语言支持等优点，成为HTTP API最常用的返回格式。当前的响应告诉客户端如何组合请求转换到所有下一个可用的状态。
3. 以资源为中心的URL设计
   资源中RESTful API的核心元素，所有的操作都是针对特定资源进行的，而资源就是用URL表示的。所以URL应该简洁、清晰、结构化，尽量使用名词，不使用动词。
 ```
https://api.example.com/v1/zoos
https://api.example.com/v1/animals
https://api.example.com/v1/employees
```
4. 使用正确的HTTP Method
  常用的方法有：
  - HEAD：只获取资源的头部信息，如文件大小、资源修改日期。
  - GET：获取资源
  - POST：在服务器新建资源
  - PUT：替换资源，客户端需要提供新建资源的所有属性
  - PATCH：更新资源的部分属性
  - DELETE：删除资源
  - OPTIONS：获取信息，关于资源支持哪些操作方法
```
  POST /zoos:新建一个动物园
  GET /zoos/ID:获取某个指定动物园的信息
  PUT /zoos/ID:更新某个指定动物园的信息,提供该动物园的全部信息
```
对不符合CRUD的操作，一种方法是把动作变成资源。用GitHub为例，“喜欢”一个gist，就增加一个`/gists/:id/star`子资源，然后对其进行操作。“喜欢”使用`PUT /gists/:id/star`，“取消喜欢”使用`DELETE /gists/:id/star` 。

# HTTP状态码
|             |  |
|-------------|--|
|1XX消息      |请求已被接受，需要继续处理，HTTP/1.1支持|
|2XX成功      |请求已成功被服务器接收、理解、并处理完毕 |
|3XX重定向    |代表客户端需要采取进一步操作才能完成请求 |
|4XX客户端错误|客户端发生了错误，请求含有词法错误或无法被执行|
|5XX服务端错误|服务器在处理请求过程中有错误或异常状态发生|

常见的HTTP状态码有：
- 200 - 请求成功
- 301 - 资源（网页等）被永久转移到其它URL
- 404 - 请求的资源（网页等）不存在
- 500 - 内部服务器错误

全部的状态码说明：[维基百科-HTTP状态码](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81)
