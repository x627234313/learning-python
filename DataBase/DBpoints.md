## 
- Hask table：散列表（哈希映射）是一种实现关联数组抽象数据类型的数据结构，这种结构可以将键映射到值。哈希表使用哈希函数来计算索引到一个桶或槽的阵列中，从中可以找到所需的值。

![](http://i64.tinypic.com/35n0vbq.jpg)

- B-tree：一种自平衡的树，能够保持数据有序。查找、顺序访问、插入、删除，都在对数时间内完成。B树通过约束所有叶子节点在相同深度来保持平衡。

![](http://i65.tinypic.com/2rptqjb.jpg)

内部节点可以拥有可变数量的子节点，内部节点中键值数量为d，则它的子节点数量为d+1。

- B+tree：B树的变体，键值的拷贝被存储在内部节点；键值和记录存储在叶子节点；另外，一个叶子节点可以包含一个指针，指向另一个叶子节点以加速顺序存取。B+树是自底向上插入。

如果B+树是m阶(order)，则除了根之外每个节点都包含最少m/2个元素最多m-1个元素。

- LSM tree：日志结构化合并树。优化写性能

![](http://i67.tinypic.com/4vfgpx.jpg)

一个两级LSM树包含两个树状结构，称为C0和C1。C0较小并且完全驻留在内存中，而C1驻留在磁盘上。新记录被插入驻留内存的C0中。如果插入导致C0超过特定大小阈值，则从C0中移除连续的条目段并合并到磁盘上的C1中。

- 1NF：第一范式是为了要排除 重复组 的出现，所采用的方法是要求数据库的每个列的值域都是由原子值组成；每个字段的值都只能是单一值。
- 2NF：
  - 符合第一范式
  - 数据表里的所有数据都要和该数据表的键（主键与候选键）有完全依赖关系：每个非键属性必须独立于任意一个候选键的任意一部分属性。
- 3NF：
  - 符合第二范式
  - 非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。
- BCNF：如果对于关系模式R中存在的任意一个非平凡函数依赖X->A，都满足X是R的一个超键，那么关系模式R就属于BCNF。
  - 符合第三范式
  - 所有非主属性都完全函数依赖于每个候选键
  - 所有主属性都完全函数依赖于不包含它的候选键
  - 没有任何属性完全函数依赖于非候选键的任意一组属性

![](http://i68.tinypic.com/2qlejcw.jpg)

## Python 中map()、reduce()函数
- map(function, iterable, ...)
  - Python中的内置函数。
  - 将function应用到可迭代对象的每一项，返回一个迭代器。如果传递了额外的iterable参数，则function必须接收许多参数，并且并行的应用到迭代对象的每一项上。
- functools.reduce(function, iterable[, initializer])
  - 将两个参数的function累积的应用到序列的成员，从左到右，以便将序列减少到单个值。
  - 如果存在可选的initializer，则在计算中将其置于序列成员之前，并在序列为空时用作默认值。

## HDFS 架构
![](http://i64.tinypic.com/xp7fiu.jpg)
