#
## Docker Registry
Registry是一个存储和内容交付系统，存储并允许你分发Docker images，可以使用不同的标记版本。

用户使用docker pull/push和Registry进行交互。

## GitFlow
![](http://i65.tinypic.com/3149wdv.jpg)
![](http://i65.tinypic.com/wtw0sk.jpg)

- `develop branch`：用于整合各个功能分支，也是开发过程中代码主要提交分支之一。
- `feature branch`：有新功能需求时，从`develop`上分出，开发完成后再合并到`develop`上，而且只能合并到`develop`上。
- `release branch`：发版日期临近或`develop`上有了足够的功能用于发布，就从`develop`上分出，为发布作准备。如果`release`测试发现bug，直接在`release`上修复，完全准备好后合并到`master`上，也要合并到`develop`上，
  - 命名规则：`release-*`  eg：`release-1.4.2`
  - 版本号命名规范：N[.N]+[{a|b|rc}N]  N为阿拉伯数字
  - 版本阶段
    - `Alpha`(内测版)
    - `Beta`（公测版）
    - `Release Candidate`（候选版）
    - `Final`（正式版）
    - 主版本号.子版本号.修正版本号  eg: 1.2a1、2.3.2b4
- `hotfix`：用于快速修复生产环境中的发行版代码，它是唯一从`master`上分出来的分支，主要是因为：
  1. 生产环境和测试环境不同，比如数据量相差较大，导致代码出现bug
  2. 确定出现bug的最原始的代码是`master`上

  修复完成后合并到`master`上，也要合并到`develop`上。
  
- `master`：记录正式发版历史，要保证这上面的代码是干净的。

## Cache
使用缓存是为了协调输入输出速度不一致的情况，应该是把一些热数据放入缓存中。缓存的存储结构越简单越好，存储的数据满足最小化原则，`刚好`满足需求。缓存是把数据暂时存起来，因此要对缓存中记录设置合理的过期时间。常用的缓存数据库有Redis、Memcache，它是key-value存储形式，数据存储在内存中。

缓存使用要注意的问题：
#### 缓存雪崩
大量并发情况下，正好缓存中的记录**同时**失效，导致大量的请求直接查询数据库，这种情况就是缓存雪崩。

解决：对缓存中数据设置不同的失效时间，让记录**分散、分批**失效，比如每过1s设置一个过期时间。

#### 缓存穿透
访问了缓存中**不存在**的记录。也可以说缓存没起作用，直接查询数据库了。

一种情况是一批热数据30分钟内访问频繁，缓存中过期时间为30分钟，结果31分钟还在频繁访问，这是一种缓存穿透情况；还一种是访问的数据，数据库中就没有。

第一种情况解决思想：大量并发请求时，设置一个互斥锁，首先允许第一个请求访问缓存，如果缓存中没有记录，查询数据库，然后把数据加入缓存中，后面的请求只会阻塞一段时间(几十毫秒)。
   
第二种情况解决思想：对参数进行合法性检查(一般在业务层进行，如果它进入到数据存储层，说明符合业务层的合法性检查，比如构造一个不存在的身份证号)，把数据库中所有的key放到一个set或list中，使用布隆过滤器或二分查找法，判断请求过来的key是否存在，不存在直接返回错误。
   
第二种情况解决思想2：把没有的变成有的。请求的key在数据库中没有，数据库返回None，我们可以把这个请求的key放入缓存中，value就是None，这样下次就直接访问缓存。这样的话过期时间不确定，如果这种数据很多，也会占用大量内存。

#### value过大
Redis中使用一个key，后面存储了大量的(百万级以上)value，数据都不过期，数据越来越大。

Redis是一种key-value存储形式的数据库，它的存储结构和MySQL等关系型数据库不一样，`{ }`相当于DB，所有记录都在里面分散的存储。存储模型应该是浅的、扁的。

{key1: value1  
key2: value2  
key3: value3  
...
}
 
 不能是这样的{key: value1, value2, .., value1000000}
 
 
