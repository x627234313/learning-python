
自20世纪40年代第一部电子通用计算机诞生至今，计算机基本上仍然采用的是存储程序结构，即冯·诺伊曼结构。

存储程序结构
- 四个主要部分：算术逻辑单元（ALU）、控制电路、存储器及输入输出设备。
- 两个核心设计原则：计算机程序和待处理的数据无差别存储在存储器中（程序也是数据的一种）、使用二进制，而非十进制。

存储器存储数据其本质是：为了状态的延续，比如：数据库中存储的数据，可以让业务系统运行状态、业务逻辑状态不断延续；硬盘中
存储的数据，可以让CPU在断电后接着上次的状态工作。如果磁盘IO速度不足，满足不了CPU的运算速度，会怎样？CPU中的运算状态中断，
等待磁盘IO完成。怎么办？在磁盘和CPU间增加一种读写更快的存储--内存。

如果随着程序的发展，又满足不了怎么办？换性能更好的存储器，一种存储器满足不了就用两种，两种不够就用三种。。。，这就是
冯·诺伊曼体系下硬件发展趋势，从CPU到一级缓存到二级缓存到内存再到硬盘。

运算和存储，就好比是两个基本元素，它们在硬件体系中存在，在软件体系中也存在。

程序是用来操作硬件的，因此程序也可以从功能上分为操作存储的和控制计算的。在我们编写程序时，可以从这两个方向着手，看要完
成的项目属于存储类还是运算类，根据这两种分类进行模块划分，在模块中进行类、函数的划分。在程序优化时也可以从这两个方面考虑。


程序是分级别、分层次的，运算和存储也能够按层次组织，大层次的元素可以囊括小层次的元素。比如在MySQL中，虽然它整体上是一个存储程序，
但是要让MySQL正确工作不仅有存储模块，必须也要有计算模块，在模块层再逐级往下有存储作用的函数，有运算作用的函数，最终落到硬件上
操作的还是存储器和计算器。


> **_计算控制存储 输入处理输出_**


__编程的核心就是，把我们解决问题的思路、方法、过程，使用计算机编程语言写成计算机程序，然后交给计算机去执行。__

编程就是在于如何去安排解决问题的流程。也就是解决问题的思想、方法、过程，也就是算法，在编程语言中**算法=数据结构+操作**，而数据在编程语言中的表现形式就是各种数据结构。程序要操作的存储器是内存，内存中存储的就是不同形式的数据结构所表现的数据,所以学习一门新的编程语言，首要关注的其如何进行内存的使用和分配，以及数据结构的操作。

编程语言是程序员与计算机沟通的语言，用来向计算机发出指令，程序员负责指示，计算机负责执行。程序就是使用编程语言编写的指示计算机每一步动作的一组指令。每解决一个相对独立的问题，都可以用一个程序来表示；而大问题可以划分为若干个小问题，一个大程序也可以按相同的逻辑来划分为几个小程序，所以程序是分层次、分级别的，也是可以嵌套的。

编程语言与代码是偏向与形式的东西，而解决问题的思想和能力是根本的，想要提升解决问题的能力，最快速的办法就是不断面临问题并解决问题。

---

> 哈希，就是将一个无限集合映射到一个有限集，如果选择理想的hash函数，能够将预期处理到的元素均匀分布到有限集中即可在O(1)时间内完成元素查找。但理想的hash函数是不存在的，且由于映射的本质(无限到有限)必然出出现一个位置有多个元素要‘占据’，这就需要解决冲突。

> 散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。

> 开放定址法：形成hash表时，某元素在第一次探测其应该占有的位置时，如果发现此处(记为A)已经被别人占了，那就在从A开始，再次探测(当然这次探测使用的hash函数与第一次已经不一样了)，如果发现还是被别人占了，那么继续探测，至到找到一个可用位置(也有可能在当下条件下永远找不到)。开放地址法有一个至关重要的问题需要解决，那就是在一个元素离开hash表时，如何处理离开后的位置状态。如果设置为原始空状态，那么后续的有效元素就无法识别了，因为在查找时同样是依据上面的探测规则进行查找，所以必须告诉探测函数某个位置虽然无有效元素了，但后续的探测可能会出现有效元素。我们可以发现，开放定址法很容易发生冲突(主要是一次探测以上成功的元素占取其它元素应该在第一次探测成功的位置)，所以就需要加大hash有效空间。

Python中字典是通过哈希表实现。
基于C语言的数据结构用于存储字典的键/值对（也称作 entry），存储内容有哈希值，键和值。PyObject 是 Python 对象的一个基类。
```
typedef struct {
    Py_ssize_t me_hash;
    PyObject *me_key;
    PyObject *me_value
} PyDictEntry;
```

下面为字典对应的数据结构。其中，ma_fill为活动槽以及哑槽（dummy slot）的总数。当一个活动槽中的键/值对被删除后，该槽则被标记为哑槽。ma_used为活动槽的总数。ma_mask值为数组的长度减 1 ，用于计算槽的索引。ma_table为数组本身，ma_smalltable为长度为 8 的初始数组。
```
typedef struct _dictobject PyDictObject;
struct _dictobject {
    PyObject_HEAD
    Py_ssize_t ma_fill;
    Py_ssize_t ma_used;
    Py_ssize_t ma_mask;
    PyDictEntry *ma_table;
    PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash);
    PyDictEntry ma_smalltable[PyDict_MINSIZE];
};
```

#### 资料：
[How are Python's Built In Dictionaries Implemented](https://stackoverflow.com/questions/327311/how-are-pythons-built-in-dictionaries-implemented)  
[深入 Python 字典的内部实现](http://python.jobbole.com/85040/)  
[python源码分析：dict对象的实现-1](http://blog.sina.com.cn/s/blog_704b6af70100yf5h.html)  
[哈希表](https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8)  
