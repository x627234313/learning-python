并行：是为了利用多核CPU加速完成多个任务。  
并发：是把程序拆分多个子任务，让多个子任务实时或近实时执行。  
非阻塞：是程序在等待某个操作时，自身可以做别的事情。提高程序整体执行效率。  
异步：不同程序执行过程中不需要通信协调，是高效组织非阻塞任务的方式。  
要支持并发，必须拆分为多任务，不同任务相对而言才有阻塞/非阻塞、同步/异步。所以，并发、异步、非阻塞三个词总是如影随形。

HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。  
HTTP有两类报文：请求报文和响应报文。  
一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。  
![img](https://github.com/x627234313/py/blob/master/08-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/clip_image002.jpg)

### Python中的concurrent.futures模块
它提供了ThreadPoolExecutor和ProcessPoolExecutor两个类，用于创建线程池和进程池。它们有两个方法属性：  
- submit():作用是提交一个可执行的回调task，并返回一个future实例。future对象代表的就是给定的调用。 Future可以理解为一个在未来完成的操作。
- map():返回一个map(func, \*iterables)迭代器，迭代器中的回调执行返回的结果有序的。

在CPU的时间观中，最耗费时间的除了重启之外，就是网络传输、磁盘读取，因此I/O成了瓶颈，而异步就是为了提高I/O效率。  
### 同步阻塞
在客户端发出connect请求，需要多长时间连接不确定，服务端什么时间返回响应数据也是不确定，客户端程序要等待这两个操作完成之后，才可以继续执行其他操作，因此这种方式效率很低。
### 多进程
为了提高效率，把一个程序执行10次，让10个一样的程序同时执行，这样执行时间有了很大的提高，但是也在一些缺点--进程切换。  
在操作系统中，有一些内核进程运行，它们开销很低并不占用用户态时间，相对应用进程的开销可以忽略，但是它们也在占用CPU，不管运行几个应用程序进程，进程数据量是肯定大于CPU核心数的，进程切换是必然，进程状态保存到内存中占用内存资源，因此这种方式支持任务规模小，最多几百进程数。
### 多线程
调度的基本单位变为线程，进程只是作为线程的容器。在程序开始执行时，进程根据线程数、所需内存，直接向操作系统申请内存；之后线程就向进程申请内存，减少操作系统开销。  
但是在Python中有GIL(全局解释器锁)，一个进程中只允许有一个线程处于运行状态。除此之外，多线程还存在竞态条件，它们被操作系统调试，调试策略是抢占式的，因此不确定下一个被执行的线程是哪个。
### 非阻塞
`socket`模块中提供了一个方法`setblocking()`来设置连接是否是阻塞的,`False`代表非阻塞，客户端程序发送`connect`请求后，不再一直等待，可以接着执行，但是它也需要知道什么时间连接成功，因此应用程序不停的`send(data)`,发送失败抛出异常，直到发送成功；在`recv()`时，应用程序也在不停的判断的接收成功。  
这种方式中虽然应用程序不在等待`connect()`成功，但是它利用空闲的时间不停的循环读写socket，执行效率和同步阻塞相当。  

可以让操作系统判断非阻塞调用是否可用，这样应用程序就可以去其他事情来提高效率。  
操作系统将I/O状态的变化都封装成了事件
